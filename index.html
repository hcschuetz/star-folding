<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<link rel="icon" href="data:;base64,=">
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Star Folding</title>
	</head>
	<body>
		<details class="with-margin" style="max-width: 950px">
			<summary>Click here to open/close explanations</summary>
			<p>
				This is an attempt to fold stars into polyhedra.
				See <a href="https://johncarlosbaez.wordpress.com/2024/10/30/triangulations-of-the-sphere-part-2/" target="_blank">here</a>
				(and <a href="https://arxiv.org/pdf/math/9801088" target="_blank">here</a>)
				for a description of the task.
			</p>
			<h2>Defining the Star</h2>
			<p>
				The first input box on this web page allows to define the star shape.
				Actually it defines the polyhedron around the star tips.
				The inner vertices of the star are computed automatically.
			</p>
			<p>
				The syntax is like this:
				Each line (which is neither empty nor starting with "//")
				contains an edge name and a list of "steps".
				Each step is given as a number from 1 to 12 corresponding to the
				directions on a clock dial.
				(If you don't know what a clock dial looks like, ask a boomer.)
			</p>
			<p>
				Even numbers go 1 unit in the respective direction.
				Odd numbers go sqrt(3) units in the respective direction so that
				we will land on a grid point again.
				(I'm following Thurston's grid layout with lines in the even clock
				directions, even though Baez' grid layout with lines in the odd clock
				directions fits with Eisenstein integers in a complex plane
				where the real axis is drawn horizontally as usual.)
			</p>
			<p>
				The example setup below creates the star given in the
				<a href="https://arxiv.org/pdf/math/9801088" target="_blank">Thurston paper</a>
				at the top of page 540 (= page 30 of the PDF):
			</p>
			<ul>
				<li>Starting at the rightmost point, we define edge "a" as sqrt(3) units in the "11 o'clock" direction.</li>
				<li>Edge "b" goes 1 unit in the "10 o'clock" direction.</li>
				<li>Edge "c" goes 1 unit in the "10 o'clock" direction and sqrt(3) units in the "9 o'clock" direction.</li>
				<li>...</li>
				<li>Finally, edge "k" goes sqrt(3) units in the "1 o'clock" direction and
					2 units in the "12 o'clock" direction, closing the loop.
				</li>
			</ul>
			<p>
				The edge names will be used as the names of the corresponding inner
				vertices of the star.  From now on we do not care anymore about the
				outer polygon.
			</p>
			<h2>Bending the Star into a Polygon</h2>
			<p>
				Now for the folding operations in the second input box below.
				The following operations are supported.
			</p>
			<h3>bend</h3>
			<p>
				A very low-level operation is to split a face with a new edge and to
				bend the edge by some amount.  "bend 1.2 a b" creates a new edge between
				vertices a and b (which should be adjacent to the boundary and to a
				common face).  The edge is bent by 1.2 radians (in one direction; if you
				want to bend in the other direction, use -1.2).  That is, the dihedral
				angle between the two new faces is &pi; - 1.2.
			</p>
			<p>
				For convenience you can write "bend 1.2 a b c a d", which introduces
				edges from a to b, from b to c, from c to a, and from a to d, each
				bent by the same angle.
			</p>
			<p>
				The primary disadvantage of this operation is that you have to know
				the bending angle in advance.  We would rather describe only the
				topology (where to insert new edges and which boundary edges to align)
				and to let the computer figure out the geometry (vertex positions,
				angles, edge lengths).
			</p>
			<h3>bend2</h3>
			<p>
				One basic operation is to select 3 inner vertices P, Q, and R and
				to bend the paper around the two line segments PQ and QR.
				The bending angles are computed automatically so that
				the two neighbor vertices of Q will coincide.
				(It is, however, not always possible to achieve this.
				In this case the operation fails.)
			</p>
			<p>
				In more detail: 
			</p>
			<ul>
				<li>
					P, Q, and R are expected to be on the boundary of our current manifold.
					The line segments PQ and QR should be
					proper diagonals of faces in our manifold.
				</li>
				<li>Let P' and R' be the neighbors of Q along the boundary
					towards P and R, respectively.</li>
				<li>After the bending the two neighbors should coincide at some point Q'.
					Apparently Q' must satisfy these conditions:
					<ol>
						<li>dist(P, Q') = dist(P, P')</li>
						<li>dist(Q, Q') = dist(Q, P')</li>
						<li>dist(Q, Q') = dist(Q, R')</li>
						<li>dist(R, Q') = dist(R, R')</li>
					</ol>
					By construction conditions 2 and 3 can be expected to be equivalent.
					So we are left with 3 sphere equations.
				</li>
				<li>
					The 3 spheres should intersect at 2 points.
					We select one of them as our Q'.
				</li>
				<li>The 2 edges PQ and QR should also divide our manifold into three parts:</li>
					<ul>
						<li>one part adjacent to PQ but not to QR,</li>
						<li>one part adjacent to both PQ and QR, and</li>
						<li>one part adjacent tot QR but not to PQ,</li>
					</ul>
					The first part (including vertex P') is rotated around PQ until P' reaches Q'.
					Similarly the third part (including R') is rotated around QR until R' reaches Q'.
				<li>
					The 2 former boundary edges P'Q and QR' are merged into a single
					non-boundary edge QQ'.
				</li>
				<li>
					It may happen (not in the first folding step, but possibly later)
					that the two faces adjacent to QQ' are in the same plane.
					In this case the edge QQ' is dropped and the two faces are merged.
					The purpose of this merger is that the merged face provides additional
					diagonals that can be used in subsequent operations.
				</li>
			</ul>
			<p>
				All this is implemented as the operation "bend2".
				It takes a "+" or "-" as its first argument
				to select one intersection point or the other
				(Most of the time just use "+".)
				and then 3 names of inner star vertices
				as the vertices P, Q, and R above.
			</p>
			<h3>reattach</h3>
			<p>
				Unfortunately it turns out that after a few "bend2" operations we
				get stuck without having reached a polyhedron.
				We can advance a bit more if we re-arrange pieces of the star.
				For example we can cut the star at edge b-c and then paste the snippet
				to the rest of the star again in such a way that the two boundary
				edges adjacent to c will coincide.
				The snippet is essentially rotated around c as far as needed so that
				the two neighbors of c along the boundary will coincide.
				This operation is written as "reattach b c".
			</p>
			<p>
				After a reattach operation there are new diagonals,
				which can be used in subsequent bending operations.
			</p>
			<p>
				In more detail:
			</p>
			<ul>
				<li>
					"reattach P Q" expects vertices P and Q
					<ul>
						<li>to be on the manifold boundary and</li>
						<li>to be adjacent to a common face.</li>
					</ul>	
				</li>
				<li>
					It cuts P and the face along the line segment P-Q.
					This cuts the manifold into two pieces that are only connected at Q.
					Two new boundary edges are introduced.
					Now glue the two pieces together at the two "old" boundary edges
					adjacent to Q.
				</li>
				<li>
					To get the geometry right again, one of the pieces needs to be rotated
					around Q.
					The implementation moves the smaller piece, which makes the operation
					easier to follow in the display.
				</li>
				<li>
					The rotation is done in such a way that
					<ul>
						<li>the glued edges align and</li>
						<li>the two faces adjacent to the glued edges
							(which may or may not be the fragments of the initial face)
							are in a common plane.</li>
					</ul>
				</li>
				<li>
					The two faces are merged into a single one.
				</li>
			</ul>
			<h3>More Operations</h3>
			<p>
				(Read this section after some experimentation with
				"reattach" and "bend2".)
			</p>
			<p>
				I have not yet managed to find a "complete" folding reaching a
				polyhedron.
				"bend2" is a constraint-solving operation finding two bending angles
				simultaneously such that two edges will align.
				Probably we need solvers for more complex constraints (e.g. involving
				three bending angles).
			</p>
			<p>
				Or do we know the shape of the folded polyhedron from some theory?
				(I do not understand very much in the Thurston paper.)
				Then we might be able to perform the folding
				in a straight-forward manner
				bending the star at the edges of the target polyhedron.
			</p>
			<h2>Output</h2>
			<p>
				To execute the operations, click the "run" button.
				Then you can select the step after which you want to see the manifold.
				There are also a few more options to customize the view.
			</p>
			<p>
				You can use your mouse to zoom and to rotate the camera around the manifold.
				(For details see <a
				href="https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#arc-rotate-camera"
				target="_blank">here</a>.)
				To scroll the entire page move the mouse pointer out of the
				graphics canvas.
			</p>
			<p>
				Below the graphic output the steps are listed again.
				Clicking a step opens/closes a bunch of log messages.
				These are intended for myself during development
				but some of them might be helpful for you as well.
				For example an exception mentioning a "negative discriminant"
				indicates that a quadradic equation could not be solved.
				This means that some spheres or circles do not intersect as expected.
			</p>
			<p>
				Operations may fail due to unmet preconditions
				(or due to implementation bugs).
				Unfortunately most error messages are not yet very helpful.
				(Better error reporting should be implemented.)
				But at least it is clarified which step was the first one
				to have a problem.
			</p>
		</details>
		<div id="app"></div>
		<script type="module" src="/src/index.tsx"></script>
	</body>
</html>
