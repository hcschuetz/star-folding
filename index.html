<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<link rel="icon" href="data:;base64,=">
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Star Folding</title>
	</head>
	<body>
		<details class="explanation" style="max-width: 950px">
			<summary>Click here to open/close explanations</summary>
			<p>
				This is an attempt to fold stars into polyhedra.
				See <a href="https://johncarlosbaez.wordpress.com/2024/10/30/triangulations-of-the-sphere-part-2/" target="_blank">here</a>
				(and <a href="https://arxiv.org/pdf/math/9801088" target="_blank">here</a>)
				for a description of the task.
			</p>
			<h2>Defining the Star</h2>
			<p>
				The first input box on this web page allows to define the star shape.
				Actually it defines the polyhedron around the star tips.
				The inner vertices of the star are computed automatically.
			</p>
			<p>
				The syntax is like this:
				Each line (which is neither empty nor starting with "//")
				contains an edge name and a list of "steps".
				Each step is given as a number from 1 to 12 corresponding to the
				directions on a clock dial.
				(If you don't know what a clock dial looks like, ask a boomer.)
			</p>
			<p>
				Even numbers go 1 unit in the respective direction.
				Odd numbers go sqrt(3) units in the respective direction so that
				we will land on a grid point again.
				(I'm following Thurston's grid layout with lines in the even clock
				directions, even though Baez' grid layout with lines in the odd clock
				directions fits with Eisenstein integers in a complex plane
				where the real axis is drawn horizontally as usual.)
			</p>
			<p>
				The example setup below creates the star given in the
				<a href="https://arxiv.org/pdf/math/9801088" target="_blank">Thurston paper</a>
				at the top of page 540 (= page 30 of the PDF):
			</p>
			<ul>
				<li>Starting at the rightmost point, we define edge "a" as sqrt(3) units in the "11 o'clock" direction.</li>
				<li>Edge "b" goes 1 unit in the "10 o'clock" direction.</li>
				<li>Edge "c" goes 1 unit in the "10 o'clock" direction and sqrt(3) units in the "9 o'clock" direction.</li>
				<li>...</li>
				<li>Finally, edge "k" goes sqrt(3) units in the "1 o'clock" direction and
					2 units in the "12 o'clock" direction, closing the loop.
				</li>
			</ul>
			<p>
				The edge names will be used as the names of the corresponding inner
				vertices of the star.  From now on we do not care anymore about the
				outer polygon.
			</p>
			<h2>Bending the Star into a Polygon</h2>
			<p>
				Now for the folding operations in the second input box below.
				The following operations are supported.
			</p>
			<h3>bend2</h3>
			<p>
				One basic operation is to select 3 inner vertices P, Q, and R and
				to bend the paper along the two line segments PQ and QR.
				The bending angles are chosen automatically so that
				the two neighbor vertices of Q will coincide.
			</p>
			<p>
				In more detail: 
			</p>
			<ul>
				<li>
					P, Q, and R are expected to be on the boundary of our current manifold.
					(Actually the code has been written with the assumption
					that the boundary at Q is to the right of the chain P->Q->R.
					If it is on the left, just exchange P and R.)
					The line segments PQ and QR should be
					proper diagonals of faces in our manifold.
				</li>
				<li>Let P' and R' be the neighbors of Q along the boundary
					towards P and R, respectively.</li>
				<li>After the bending the two neighbors should coincide at some point Q'.
					Apparently Q' must satisfy these conditions:
					<ol>
						<li>dist(P, Q') = dist(P, P')</li>
						<li>dist(Q, Q') = dist(Q, P')</li>
						<li>dist(Q, Q') = dist(Q, R')</li>
						<li>dist(R, Q') = dist(R, R')</li>
					</ol>
					By construction conditions 2 and 3 can be expected to be equivalent.
					So we are left with 3 sphere equations.
				</li>
				<li>
					The 3 spheres should intersect at 2 points.
					We select one of them as our Q'.
				</li>
				<li>The 2 edges PQ and QR should also divide our manifold into three parts:</li>
					<ul>
						<li>one part adjacent to PQ but not to QR,</li>
						<li>one part adjacent to both PQ and QR, and</li>
						<li>one part adjacent tot QR but not to PQ,</li>
					</ul>
					The first part (including vertex P') is rotated around PQ until P' reaches Q'.
					Similarly the third part (including R') is rotated around QR until R' reaches Q'.
				<li>
					The 2 former boundary edges P'Q and QR' are merged into a single
					non-boundary edge QQ'.
				</li>
				<li>
					It may happen (not in the first folding step, but possibly later)
					that the two faces adjacent to QQ' are in the same plane.
					In this case the edge QQ' is dropped and the two faces are merged.
					The purpose of this merger is that the merged face provides additional
					diagonals that can be used in subsequent operations.
				</li>
			</ul>
			<p>
				All this is implemented as the operation "bend2".
				It takes a "+" or "-" as its first argument
				to select one intersection point or the other
				(Most of the time just use "+".)
				and then 3 names of inner star vertices
				as the vertices P, Q, and R above.
			</p>
			<h3>reattachL</h3>
			<p>
				Unfortunately it turned out that after a few "bend2" operations we
				get stuck without having reached a polyhedron.
				We can advance a bit more if we re-arrange pieces of the star.
				For example we can cut the star at edge bc and then paste the snippet
				to the rest of the star again in such a way that the two boundary
				edges adjacent to c will coincide.
				The snippet is essentially rotated around c as far as needed so that
				the two neighbors of c along the boundary will coincide.
				This operation is written as "reattachL b c".
			</p>
			<p>
				After a reattach operation there are new diagonals,
				which can be used in subsequent bending operations.
			</p>
			<h3>reattachR</h3>
			<p>
				"reattachL b c" rotates a small triangle a bit to the left.
				We would similarly like to have an operation "reattachR d e"
				rotating a small triangle a bit to the right.
				I did not yet get around to implement this.
				And it is actually not needed urgently.
				We can simply use "reattach e d", which rotates the bulk of the
				star a bit to the left around "d" and leaves the small snippet in place.
			</p>
			<h3>More Operations</h3>
			<p>
				(Read this section after some experimentation with
				"reattachL" and "bend2".)
			</p>
			<p>
				I have not yet managed to find a "complete" folding reaching a
				polyhedron.
				"bend2" is a constraint-solving operation finding two bending angles
				simultaneously such that two edges will align.
				Probably we need solvers for more complex constraints (e.g. involving
				three bending angles).
			</p>
			<p>
				Or do we know the shape of the folded polyhedron from some theory?
				(I do not understand very much in the Thurston paper.)
				Then we could perform the folding in a straight-forward manner bending
				the star at the edges of the target polyhedron.
			</p>
			<h2>Output</h2>
			<p>
				To execute the operations, click the "run" button.
				Then you can select the step after which you want to see the manifold.
				There are also a few more options to customize the view.
			</p>
			<p>
				You can use your mouse to zoom and to rotate the camera around the manifold.
				(For details see <a
				href="https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#arc-rotate-camera"
				target="_blank">here</a>.)
				To scroll the entire page move the mouse pointer out of the
				graphics canvas.
			</p>
			<p>
				Below the graphic output the steps are listed again.
				Clicking a step opens/closes a bunch of log messages.
				These are intended for myself during development
				but some of them might be helpful for you as well.
				For example an exception mentioning a "negative discriminant"
				indicates that a quadradic equation could not be solved.
				This means that some spheres or circles do not intersect as expected.
			</p>
		</details>
		<div id="app"></div>
		<script type="module" src="/src/index.tsx"></script>
	</body>
</html>
